{"ast":null,"code":"import { Column } from './column.define';\nimport { Row } from './row.define';\nexport class DataSet {\n  constructor(data = [],\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  columnSettings) {\n    this.columnSettings = columnSettings;\n    this.data = [];\n    this.columns = [];\n    this.rows = [];\n    this.createColumns(columnSettings);\n    this.setData(data);\n    this.createNewRow();\n  }\n  setData(data) {\n    this.data = data;\n    this.createRows();\n  }\n  getColumns() {\n    return this.columns;\n  }\n  getRows() {\n    return this.rows;\n  }\n  getFirstRow() {\n    return this.rows[0];\n  }\n  getLastRow() {\n    return this.rows[this.rows.length - 1];\n  }\n  findRowByData(data) {\n    return this.rows.find(row => row.getData() === data);\n  }\n  deselectAll() {\n    this.rows.forEach(row => {\n      row.isSelected = false;\n    });\n    // we need to clear selectedRow field because no one row selected\n    this.selectedRow = undefined;\n  }\n  selectRow(row) {\n    const previousIsSelected = row.isSelected;\n    this.deselectAll();\n    row.isSelected = !previousIsSelected;\n    this.selectedRow = row;\n    return this.selectedRow;\n  }\n  multipleSelectRow(row) {\n    row.isSelected = !row.isSelected;\n    this.selectedRow = row;\n    return this.selectedRow;\n  }\n  selectPreviousRow() {\n    if (this.rows.length > 0) {\n      let index = this.selectedRow ? this.selectedRow.index : 0;\n      if (index > this.rows.length - 1) {\n        index = this.rows.length - 1;\n      }\n      this.selectRow(this.rows[index]);\n      return this.selectedRow;\n    }\n  }\n  selectFirstRow() {\n    if (this.rows.length > 0) {\n      this.selectRow(this.rows[0]);\n      return this.selectedRow;\n    }\n  }\n  selectLastRow() {\n    if (this.rows.length > 0) {\n      this.selectRow(this.rows[this.rows.length - 1]);\n      return this.selectedRow;\n    }\n  }\n  selectRowByIndex(index) {\n    const rowsLength = this.rows.length;\n    if (rowsLength === 0) {\n      return;\n    }\n    if (!index) {\n      this.selectFirstRow();\n      return this.selectedRow;\n    }\n    if (index > 0 && index < rowsLength) {\n      this.selectRow(this.rows[index]);\n      return this.selectedRow;\n    }\n    // we need to deselect all rows if we got an incorrect index\n    this.deselectAll();\n  }\n  willSelectFirstRow() {\n    this.willSelect = 'first';\n  }\n  willSelectLastRow() {\n    this.willSelect = 'last';\n  }\n  select(selectedRowIndex) {\n    if (this.getRows().length === 0) {\n      return;\n    }\n    if (this.willSelect) {\n      if (this.willSelect === 'first') {\n        this.selectFirstRow();\n      }\n      if (this.willSelect === 'last') {\n        this.selectLastRow();\n      }\n      this.willSelect = '';\n    } else {\n      this.selectRowByIndex(selectedRowIndex);\n    }\n    return this.selectedRow;\n  }\n  createNewRow() {\n    this.newRow = new Row(-1, {}, this);\n    this.newRow.isInEditing = true;\n  }\n  /**\n   * Create columns by mapping from the settings\n   *\n   * @param settings\n   * @private\n   */\n  createColumns(settings) {\n    for (const id in settings) {\n      if (settings.hasOwnProperty(id)) {\n        this.columns.push(new Column(id, settings[id], this));\n      }\n    }\n  }\n  /**\n   * Create rows based on current data prepared in data source\n   *\n   * @private\n   */\n  createRows() {\n    this.rows = [];\n    this.data.forEach((el, index) => {\n      this.rows.push(new Row(index, el, this));\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}